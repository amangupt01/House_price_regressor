# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ax-3bxz-Dc9VssbqraS_y4JoDu8lPkI_
"""

from google.colab import files
uploaded = files.upload()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
S = pd.read_csv('train.csv')
S.head()

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import norm
from sklearn.preprocessing import StandardScaler
from scipy import stats
import warnings
warnings.filterwarnings('ignore')
# %matplotlib inline

var = 'YearBuilt'
data = pd.concat([S['SalePrice'], S[var]], axis=1)
f, ax = plt.subplots(figsize=(16, 8))
fig = sns.boxplot(x=var, y="SalePrice", data=data)
fig.axis(ymin=0, ymax=800000);
plt.xticks(rotation=90);

print(set(S.isnull().sum()))

S.columns.tolist()

def handle_non_numerical_data(df):
    columns = df.columns.values
    for column in columns:
        text_digit_vals = {}
        def convert_to_int(val):
            return text_digit_vals[val]

        if df[column].dtype != np.int64 and df[column].dtype != np.float64:
            column_contents = df[column].values.tolist()
            unique_elements = set(column_contents)
            x = 0
            for unique in unique_elements:
                if unique not in text_digit_vals:
                    text_digit_vals[unique] = x
                    x+=1

            df[column] = list(map(convert_to_int, df[column]))

    return df

S.fillna(0, inplace=True)
handle_non_numerical_data(S)

S.isnull().sum()

S = S.drop('Id',axis = 1)
y = S.SalePrice
S = S.drop('SalePrice',axis = 1)
S.head()
y.head()

import numpy as np 
import pandas as pd 
import seaborn as sns 
import matplotlib.pyplot as plt 
from sklearn import preprocessing, svm 
from sklearn.model_selection import train_test_split 
from sklearn.linear_model import LinearRegression


X_train, X_test, y_train, y_test = train_test_split(S, y, test_size = 0.25)

X_train.head()

alpha = np.mean(X_train,axis = 0)
beta = np.std(X_train,axis = 0)

X_train = (X_train+alpha)/beta
X_test = (X_test+alpha)/beta

X_train.isnull().sum()

regr = LinearRegression() 
  
regr.fit(X_train, y_train) 
print(regr.score(X_test, y_test))

from sklearn.svm import SVR
clf = SVR(C=100, epsilon=0.2,kernel = 'linear')
clf.fit(X_train,y_train)

clf.score(X_test,y_test)

from sklearn.ensemble import RandomForestRegressor
regr = RandomForestRegressor(max_depth=2, random_state=0)
regr.fit(X_train, y_train)

regr.score(X_test,y_test)

from sklearn import ensemble
original_params = {'n_estimators': 1000, 'max_leaf_nodes': 4, 'max_depth': None, 'random_state': 2,
                   'min_samples_split': 5}
params = dict(original_params)
clg = ensemble.GradientBoostingRegressor(**params)
clg.fit(X_train, y_train)

clg.score(X_test,y_test)

from google.colab import files
uploaded = files.upload()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
R = pd.read_csv('test.csv')
R.head()
R = R.drop('Id',axis =1 )

R.fillna(0, inplace=True)
handle_non_numerical_data(R)

R = (R+alpha)/beta

R.head()

ans = clg.predict(R)

df1 = pd.read_csv('test.csv')
df1.shape

df1['SalePrice'] = ans

myans = df1[["Id","SalePrice"]]

myans.to_csv('stupid.csv', index = False)